import json
from typing import Dict, Any, List, Tuple

from src.models.workout import WeeklyPlan, DailyPlan, ProposedWorkout
from src.utils.zwift_workout_generator import generate_zwift_workout

# Default user FTP in watts - adjust this as your fitness changes
DEFAULT_FTP = 258

def parse_proposed_workouts_json(json_file_path: str) -> Dict[str, Any]:
    """
    Parses the proposed workouts JSON file and returns a dictionary.
    """
    try:
        with open(json_file_path, 'r') as f:
            data = json.load(f)
        return data
    except FileNotFoundError:
        raise FileNotFoundError(f"File not found: {json_file_path}")
    except json.JSONDecodeError:
        raise ValueError(f"Invalid JSON format in: {json_file_path}")

def safe_get_int(data: Dict[str, Any], key: str, default: int = 0) -> int:
    """
    Safely extracts an integer value from a dictionary, handling various types.
    """
    value = data.get(key)
    if value is None:
        return default
    
    # Handle different input types
    try:
        if isinstance(value, str):
            # Handle string ranges like "25-30" by taking the average
            if "-" in value:
                parts = value.split("-")
                if len(parts) == 2:
                    try:
                        return int((int(parts[0]) + int(parts[1])) / 2)
                    except ValueError:
                        return default
            # Try to convert string to int
            return int(float(value))
        elif isinstance(value, (int, float)):
            return int(value)
        else:
            return default
    except (ValueError, TypeError):
        return default

def process_proposed_workouts(json_file_path: str) -> Tuple[WeeklyPlan, List[DailyPlan], List[ProposedWorkout]]:
    """
    Parses, validates, and processes the proposed workouts JSON file.
    """
    data = parse_proposed_workouts_json(json_file_path)

    # Extract and convert plannedTSS values safely
    planned_tss = data.get('plannedTSS', {})
    if isinstance(planned_tss, dict):
        tss_min = safe_get_int(planned_tss, 'min')
        tss_max = safe_get_int(planned_tss, 'max')
    else:
        # Handle case where plannedTSS might be a single value or other format
        tss_min = tss_max = safe_get_int({'value': planned_tss}, 'value')

    # Create weekly plan with proper type conversions
    weekly_plan = WeeklyPlan(
        weekNumber=safe_get_int(data, 'weekNumber'),
        startDate=data.get('startDate', ''),
        plannedTSS_min=tss_min,
        plannedTSS_max=tss_max,
        notes=json.dumps(data.get('notes', '')) if isinstance(data.get('notes'), dict) else str(data.get('notes', '')),
        ftp=safe_get_int(data, 'ftp') if 'ftp' in data else None
    )
    
    daily_plans = []
    proposed_workouts = []

    for day in data.get('days', []):
        daily_plan = DailyPlan(
            id=0,  # The ID will be auto-generated by the database
            weekNumber=weekly_plan.weekNumber,
            dayNumber=safe_get_int(day, 'dayNumber'),
            date=day.get('date', '')
        )
        daily_plans.append(daily_plan)

        for workout in day.get('workouts', []):
            # Extract workout data safely with type conversion
            workout_type = workout.get('type', '')
            workout_name = workout.get('name', '')
            planned_duration = safe_get_int(workout, 'plannedDuration')
            
            # Handle planned TSS values
            workout_tss = workout.get('plannedTSS', {})
            if isinstance(workout_tss, dict):
                planned_tss_min = safe_get_int(workout_tss, 'min')
                planned_tss_max = safe_get_int(workout_tss, 'max')
            else:
                planned_tss_min = planned_tss_max = safe_get_int({'value': workout_tss}, 'value')
            
            # Handle target RPE values
            target_rpe = workout.get('targetRPE', {})
            if isinstance(target_rpe, dict):
                target_rpe_min = safe_get_int(target_rpe, 'min')
                target_rpe_max = safe_get_int(target_rpe, 'max')
            else:
                target_rpe_min = target_rpe_max = safe_get_int({'value': target_rpe}, 'value')
            
            # Always convert intervals and sections to JSON strings
            intervals = workout.get('intervals', [])
            if not isinstance(intervals, str):
                intervals = json.dumps(intervals)
                
            sections = workout.get('sections', [])
            if not isinstance(sections, str):
                sections = json.dumps(sections)
                
            # Extract notes and convert to JSON string if it's a list/dict
            notes = workout.get('notes', [])
            if isinstance(notes, (list, dict)):
                notes = json.dumps(notes)
            elif notes is None:
                notes = ""
            else:
                notes = str(notes)
            
            proposed_workout = ProposedWorkout(
                id=0,  # The ID will be auto-generated by the database
                dailyPlanId=0,  # The dailyPlanId will be assigned later
                type=workout_type,
                name=workout_name,
                plannedDuration=planned_duration,
                plannedTSS_min=planned_tss_min,
                plannedTSS_max=planned_tss_max,
                targetRPE_min=target_rpe_min,
                targetRPE_max=target_rpe_max,
                intervals=intervals,
                sections=sections,
                notes=notes
            )
            # Add a temporary reference to the dayNumber for matching later
            # Record dayNumber on the dataclass (optional field) for later matching
            proposed_workout.dayNumber = safe_get_int(day, 'dayNumber')
            proposed_workouts.append(proposed_workout)
            
            # Generate Zwift .zwo file if it's a cycling workout with intervals
            if workout_type.lower() == 'bike' and workout.get('intervals'):
                try:
                    # Extract FTP from weekly plan - try explicit FTP field first, then notes as fallback
                    extracted_ftp = DEFAULT_FTP  # Use default as ultimate fallback
                    
                    # First, check for explicit FTP field in weekly plan
                    if weekly_plan and hasattr(weekly_plan, 'ftp') and weekly_plan.ftp:
                        extracted_ftp = weekly_plan.ftp
                        print(f"Using explicit FTP: {extracted_ftp}W from weekly plan")
                    else:
                        # Fallback to parsing FTP from notes
                        try:
                            if weekly_plan and weekly_plan.notes:
                                notes_data = json.loads(weekly_plan.notes) if isinstance(weekly_plan.notes, str) else weekly_plan.notes
                                if isinstance(notes_data, dict):
                                    special_considerations = notes_data.get('specialConsiderations', '')
                                    # Look for FTP pattern like "FTP 300W confirmed" or "FTP: 300W"
                                    import re
                                    ftp_match = re.search(r'FTP[:\s]*(\d+)W?', special_considerations, re.IGNORECASE)
                                    if ftp_match:
                                        extracted_ftp = int(ftp_match.group(1))
                                        print(f"Extracted FTP: {extracted_ftp}W from weekly plan notes (fallback)")
                        except Exception as e:
                            print(f"Could not extract FTP from weekly plan notes: {e}, using default {extracted_ftp}W")
                    
                    generate_zwift_workout(
                        workout_date=day.get('date', ''),
                        workout_name=workout_name,
                        intervals=json.loads(intervals) if isinstance(intervals, str) else workout.get('intervals', []),
                        description=workout.get('description', ''),
                        ftp=extracted_ftp,
                        week_number=weekly_plan.weekNumber
                    )
                except Exception as e:
                    print(f"Error generating Zwift workout: {str(e)}")

    return weekly_plan, daily_plans, proposed_workouts